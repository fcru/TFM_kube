
# Function to calculate shortest path using Dijkstra's algorithm
def calculate_shortest_path(neo4j_conn, start_station_id, end_station_id):
    cypher_query = """
    MATCH (start:Station_to_Intervent {station_id: $start_station_id}),
          (end:Station_to_Intervent {station_id: $end_station_id})
    CALL gds.shortestPath.dijkstra.stream({
        sourceNode: start,
        targetNode: end,
        relationshipWeightProperty: 'distance'
    })
    YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs
    RETURN totalCost, nodeIds, costs
    """
    # Run the query with the provided station IDs
    result = neo4j_conn.query(cypher_query, parameters={"start_station_id": start_station_id, "end_station_id": end_station_id})

    for record in result:
        print(f"Total Distance: {record['totalCost']}")
        print(f"Path Node IDs: {record['nodeIds']}")
        print(f"Segment Costs: {record['costs']}")
    return result

# Calculate shortest paths between multiple stations
def calculate_route_through_stations(neo4j_conn, station_list):
    total_cost = 0
    full_path = []
    for i in range(len(station_list) - 1):
        start_station = station_list[i]
        end_station = station_list[i+1]
        result = calculate_shortest_path(neo4j_conn, start_station, end_station)
        for record in result:
            total_cost += record["totalCost"]
            full_path.extend(record["nodeIds"])  # Accumulate path nodes
    return total_cost, full_path

# Function to calculate the shortest path between multiple stations, keeping the first station fixed
def find_optimal_route_fixed_start(neo4j_conn, start_station, station_list):
    min_distance = float('inf')
    optimal_path = None

    # Generate all possible permutations of the station list (except the start station)
    for perm in itertools.permutations(station_list):
        # Add the start station at the beginning of the route
        full_route = [start_station] + list(perm)
        # Calculate the total distance and path for this route
        total_distance, route_path = calculate_route_through_stations(neo4j_conn, full_route)
        # Update the optimal path if the current one is shorter
        if total_distance < min_distance:
            min_distance = total_distance
            optimal_path = route_path

    return min_distance, optimal_path

# Retrieve the list of clusters (trucks) from the Neo4j database
clusters_df = spark.read \
    .format("org.neo4j.spark.DataSource") \
    .option("url", uri) \
    .option("labels", "Station_to_Intervent") \
    .load() \
    .select("truck") \
    .distinct()

# Collect the list of clusters
clusters = [row["truck"] for row in clusters_df.collect()]

# For each cluster, calculate the optimal route
for truck in clusters:
    # Retrieve the list of station IDs for the current cluster
    stations_df = spark.read \
        .format("org.neo4j.spark.DataSource") \
        .option("url", uri) \
        .option("labels", "Station_to_Intervent") \
        .load() \
        .filter(col("truck") == truck) \
        .select("station_id")

    station_list = [row["station_id"] for row in stations_df.collect()]

    if not station_list:
        print(f"No stations found for truck {truck}")
        continue

    # Store the first station ID in a variable called start_station
    start_station = station_list[0]

    # Remove the first station ID from the list
    remaining_stations = station_list[1:]

    # Establish Neo4j connection
    neo4j_conn = Neo4jConnection(uri, "", "")

    # Call the function to calculate the optimal route with a fixed start
    min_distance, optimal_route = find_optimal_route_fixed_start(neo4j_conn, start_station, remaining_stations)

    # Close the Neo4j connection
    neo4j_conn.close()

    # Print the results
    print(f"Truck {truck} - Optimal Distance: {min_distance}")
    print(f"Truck {truck} - Optimal Route Path: {optimal_route}")
